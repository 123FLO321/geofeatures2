//===--- CoordinateCollection.swift.gyb -------------------------------------*- swift -*-===//
//
// NOTE: This file was auto generated by gyb from file GeometryCollection.swift.gyb.
//
// Do NOT edit this file directly as it will be regenerated automatically when needed.
//

/*
 *   LineString.swift
 *
 *   Copyright 2016 Tony Stone
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *   Created by Tony Stone on 2/14/16.
 */
import Swift

/**
    LineString
 
    A LineString is a Curve with linear interpolation between Coordinates. Each consecutive pair of
    Coordinates defines a Line segment.
 */
public struct LineString<Element : protocol<Coordinate, TupleConvertable>> : Geometry {
    
    public let precision: Precision
    public let coordinateReferenceSystem: CoordinateReferenceSystem
    
    public init(coordinateReferenceSystem: CoordinateReferenceSystem = defaultCoordinateReferenceSystem, precision: Precision = defaultPrecision) {
        self.precision = precision
        self.coordinateReferenceSystem = coordinateReferenceSystem
    }
    
    private var coordinates = ContiguousArray<Element>()
}

// MARK: Collection conformance

extension LineString : Collection  {
    
    /**
        LineString can be constructed from any SequenceType as long as it has an
        Element type equal the Coordinate type specified in Element.
     */
    public init<S : SequenceType where S.Generator.Element == Element>(elements: S, coordinateReferenceSystem: CoordinateReferenceSystem = defaultCoordinateReferenceSystem, precision: Precision = defaultPrecision) {
        
        self.init(coordinateReferenceSystem: coordinateReferenceSystem, precision: precision)
        
        var generator = elements.generate()
        
        while var coordinate = generator.next() {
            self.precision.convert(&coordinate)
            
            self.coordinates.append(coordinate)
        }
    }
    
    /**
        LineString can be constructed from any CollectionType including Array as
        long as it has an Element type equal the Coordinate type specified in Element 
        and the Distance is an Int type.
     */
    public init<C : CollectionType where C.Generator.Element == Element, C.Index.Distance == Int>(elements: C, coordinateReferenceSystem: CoordinateReferenceSystem = defaultCoordinateReferenceSystem, precision: Precision = defaultPrecision) {
        
        self.init(coordinateReferenceSystem: coordinateReferenceSystem, precision: precision)
        
        self.coordinates.reserveCapacity(elements.count)
        
        var generator = elements.generate()
        
        while var coordinate = generator.next() {
            self.precision.convert(&coordinate)
            
            self.coordinates.append(coordinate)
        }
    }
    
    /**
        - Returns: The number of Coordinate3D objects.
     */
    public var count: Int {
        get { return self.coordinates.count }
    }
    
    /**
        - Returns: The current minimum capacity.
     */
    public var capacity: Int {
        get { return self.coordinates.capacity }
    }
    
    /**
        Reserve enough space to store `minimumCapacity` elements.
     
        - Postcondition: `capacity >= minimumCapacity` and the array has mutable contiguous storage.
     */
    public mutating func reserveCapacity(minimumCapacity: Int) {
        self.coordinates.reserveCapacity(minimumCapacity)
    }
    
    /**
        Reserve enough space to store `minimumCapacity` elements.
     
        - Postcondition: `capacity >= minimumCapacity` and the array has mutable contiguous storage.
     */
    public mutating func append(newElement: Element) {
        var convertedCoordinate = newElement
        
        self.precision.convert(&convertedCoordinate)
        
        self.coordinates.append(convertedCoordinate)
    }
    
    /**
        Append the elements of `newElements` to this LineString.
     */
    public mutating func appendContentsOf<S : SequenceType where S.Generator.Element == Element>(newElements: S) {
        
        var generator = newElements.generate()
        
        while var coordinate = generator.next() {
            self.precision.convert(&coordinate)
            
            self.coordinates.append(coordinate)
        }
    }
    
    /**
        Append the elements of `newElements` to this LineString.
     */
    public mutating func appendContentsOf<C : CollectionType where C.Generator.Element == Element>(newElements: C) {
        
        var generator = newElements.generate()
        
        while var coordinate = generator.next() {
            self.precision.convert(&coordinate)
            
            self.coordinates.append(coordinate)
        }
    }
    
    /**
        Remove an element from the end of this LineString.
     
        - Requires: `count > 0`.
     */
    public mutating func removeLast() -> Element {
        return self.coordinates.removeLast()
    }
    
    /**
        Insert `newElement` at index `i` of this LineString.
     
        - Requires: `i <= count`.
     */
    public mutating func insert(newElement: Element, atIndex i: Int) {
        var convertedCoordinate = newElement
        
        self.precision.convert(&convertedCoordinate)
        
        self.coordinates.insert(convertedCoordinate, atIndex: i)
    }
    
    /**
        Remove and return the element at index `i` of this LineString.
     */
    public mutating func removeAtIndex(index: Int) -> Element {
        return self.coordinates.removeAtIndex(index)
    }
    
    /**
        Remove all elements of this LineString.
     
        - Postcondition: `capacity == 0` iff `keepCapacity` is `false`.
     */
    public mutating func removeAll(keepCapacity keepCapacity: Bool = true) {
        self.coordinates.removeAll(keepCapacity: keepCapacity)
    }
}

/**
    TupleConvertable extensions
 
    Coordinates that are TupleConvertable allow initialization via an ordinary Swift tuple.
 */
extension LineString where Element : TupleConvertable {
    
    /**
        LineString can be constructed from any SequenceType if it's Elements are tuples that match
        Self.Element's TupleType.  
     
        ----
     
        - seealso: TupleConvertable.
     */
    public init<S : SequenceType where S.Generator.Element == Element.TupleType>(elements: S, coordinateReferenceSystem: CoordinateReferenceSystem = defaultCoordinateReferenceSystem, precision: Precision = defaultPrecision) {
        
        self.init(coordinateReferenceSystem: coordinateReferenceSystem, precision: precision)
        
        var generator = elements.generate()
        
        while let coordinate = generator.next() {
            var convertedCoordinate = Element(tuple: coordinate)
            
            self.precision.convert(&convertedCoordinate)
            
            self.coordinates.append(convertedCoordinate)
        }
    }
    
    /**
        LineString can be constructed from any CollectionType if it's Elements are tuples that match
        Self.Element's TupleType.  
     
        ----
     
        - seealso: TupleConvertable.
     */
    public init<C : CollectionType where C.Generator.Element == Element.TupleType, C.Index.Distance == Int>(elements: C, coordinateReferenceSystem: CoordinateReferenceSystem = defaultCoordinateReferenceSystem, precision: Precision = defaultPrecision) {
        
        self.init(coordinateReferenceSystem: coordinateReferenceSystem, precision: precision)
        
        self.coordinates.reserveCapacity(elements.count)
        
        var generator = elements.generate()
        
        while let coordinate = generator.next() {
            var convertedCoordinate = Element(tuple: coordinate)
            
            self.precision.convert(&convertedCoordinate)
            
            self.coordinates.append(convertedCoordinate)
        }
    }
    
    /**
        Reserve enough space to store `minimumCapacity` elements.
     
        - Postcondition: `capacity >= minimumCapacity` and the array has mutable contiguous storage.
     */
    public mutating func append(newElement: Element.TupleType) {
        var convertedCoordinate = Element(tuple: newElement)
        
        self.precision.convert(&convertedCoordinate)
        
        self.coordinates.append(convertedCoordinate)
    }
    
    /**
        Append the elements of `newElements` to this LineString.
     */
    public mutating func appendContentsOf<S : SequenceType where S.Generator.Element == Element.TupleType>(newElements: S) {
        
        var generator = newElements.generate()
        
        while let coordinate = generator.next() {
            var convertedCoordinate = Element(tuple: coordinate)
            
            self.precision.convert(&convertedCoordinate)
            
            self.coordinates.append(convertedCoordinate)
        }
    }
    
    /**
        Append the elements of `newElements` to this LineString.
     */
    public mutating func appendContentsOf<C : CollectionType where C.Generator.Element == Element.TupleType>(newElements: C) {
        
        var generator = newElements.generate()
        
        while let coordinate = generator.next() {
            var convertedCoordinate = Element(tuple: coordinate)
            
            self.precision.convert(&convertedCoordinate)
            
            self.coordinates.append(convertedCoordinate)
        }
    }
    
    /**
        Insert `newElement` at index `i` of this LineString.
     
        - Requires: `i <= count`.
     */
    public mutating func insert(newElement: Element.TupleType, atIndex i: Int) {
        var convertedCoordinate = Element(tuple: newElement)
        
        self.precision.convert(&convertedCoordinate)
        
        self.coordinates.insert(convertedCoordinate, atIndex: i)
    }
}


// MARK: CollectionType conformance

extension LineString : CollectionType, MutableCollectionType, _DestructorSafeContainer {
    
    /**
        Always zero, which is the index of the first element when non-empty.
     */
    public var startIndex : Int { return self.coordinates.startIndex }
    
    /**
        A "past-the-end" element index; the successor of the last valid subscript argument.
     */
    public var endIndex   : Int { return self.coordinates.endIndex }
    
    public subscript(position : Int) -> Element {
        
        get {
            return self.coordinates[position]
        }
        
        set (value) {
            var convertedCoordinate = value
            
            self.precision.convert(&convertedCoordinate)
            
            self.coordinates[position] = convertedCoordinate
        }
    }
    
    public subscript(range: Range<Int>) -> ArraySlice<Element> {
        get {
            return self.coordinates[range]
        }
        
        set (value) {
            // TODO: precision convert the values before putting them in
            self.coordinates[range] = value
        }
    }
    
    public func generate() -> IndexingGenerator<ContiguousArray<Element>> {
        return self.coordinates.generate()
    }
}

// MARK: CustomStringConvertible & CustomDebugStringConvertible Conformance

extension LineString : CustomStringConvertible, CustomDebugStringConvertible {
    
    public var description : String {
        return "\(self.dynamicType)(\(self.coordinates.description))"
    }
    
    public var debugDescription : String {
        return self.description
    }
}

